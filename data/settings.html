<!DOCTYPE html>
<html>

<head>
    <title>Aquarium Settings</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="/favicon.jpg">
    <meta name="theme-color" content="#33afff">
    <style>
        body {
            background: #121212;
            color: #fff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px 20px 40px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .page-header {
            background: #1e1e1e;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 1rem;
            width: 100%;
            max-width: 600px;
            box-sizing: border-box;
            text-align: center;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            padding: 0 60px;
            box-sizing: border-box;
        }

        .page-title {
            color: #2196F3;
            font-size: 2rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            flex: 1;
            text-align: center;
        }

        .connection-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
            position: absolute;
            right: 0;
        }

        .connection-status.online {
            background: #1b5e20;
            color: #4CAF50;
        }

        .connection-status.offline {
            background: #b71c1c;
            color: #ff5252;
        }

        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .connection-status.online .connection-dot {
            background: #4CAF50;
            box-shadow: 0 0 8px #4CAF50;
        }

        .connection-status.offline .connection-dot {
            background: #ff5252;
            box-shadow: 0 0 8px #ff5252;
        }

        .version-footer {
            margin-top: auto;
            width: 100%;
            font-size: 0.7rem;
            color: #666;
            text-align: center;
            background: #121212;
            padding: 8px 0;
            border-top: 1px solid #252525;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .copyright {
            font-size: 0.65rem;
            color: #555;
        }

        .navbar {
            width: 100%;
            max-width: 600px;
            margin-bottom: 1rem;
            display: flex;
            justify-content: center;
            padding: 8px;
            background: #1e1e1e;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .nav-btn {
            background: #252525;
            color: #2196F3;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
            margin: 2px;
        }

        .nav-btn:hover {
            background: #2196F3;
            color: white;
            transform: translateY(-1px);
        }

        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 0;
            }

            .connection-status {
                position: static;
                margin-top: 0.5rem;
            }

            .page-title {
                margin-bottom: 0.5rem;
            }

            .navbar {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .nav-btn {
                width: 100%;
                box-sizing: border-box;
            }
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }

        .settings-container {
            background: #1e1e1e;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            width: 100%;
            box-sizing: border-box;
        }

        .settings-title {
            color: #2196F3;
            font-size: 1.2rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .name-input {
            background: #252525;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
            margin: 5px 0;
        }

        .btn-set {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s;
            position: relative;
        }

        .btn-set:hover {
            background: #1976D2;
        }

        @media (max-width: 768px) {
            .grid-container {
                grid-template-columns: 1fr;
            }
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            margin-right: 6px;
            vertical-align: middle;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #2196F3;
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        #restoreOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(18, 18, 18, 0.85);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .restore-spinner {
            border: 6px solid #eee;
            border-top: 6px solid #2196F3;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
            margin-bottom: 18px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .restore-message {
            color: #fff;
            font-size: 1.1rem;
            letter-spacing: 1px;
            text-align: center;
        }

        .tooltip {
            display: none;
            position: absolute;
            background: #222;
            color: #fff;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.95em;
            z-index: 10;
            margin-top: 24px;
            box-shadow: 0 2px 8px #00000040;
            white-space: nowrap;
        }
    </style>
</head>

<body>
    <div class="page-header">
        <div class="header">
            <h2 class="page-title">Settings</h2>
            <div id="connectionStatus" class="connection-status offline">
                <span class="connection-dot"></span>
                <span>Offline</span>
            </div>
        </div>
    </div>

    <nav class="navbar">
        <button class="nav-btn" onclick="window.location.href='index.html'">Back</button>
        <button class="nav-btn" onclick="updateTime()">Update Time</button>
        <button class="nav-btn" onclick="downloadConfig()">Backup</button>
        <label class="nav-btn"
            style="cursor:pointer; text-align:center; display:flex; justify-content:center; align-items:center;">
            Restore
            <input type="file" id="restoreConfigInput" accept="application/json" style="display:none"
                onchange="restoreConfig(event)">
        </label>
    </nav>

    <!-- Clock Display -->
    <div class="settings-container" style="max-width:600px; margin-top:10px; text-align:center;">
        <span id="clockDisplay" style="font-size:1.3rem; color:#4CAF50; letter-spacing:1px;">--:-- --, ----
            --/--/----</span>
    </div>

    <!-- WiFi Settings -->
    <div class="settings-container" style="max-width:600px; margin-top:10px;">
        <h3 class="settings-title">WiFi Settings</h3>
        <form id="wifiForm" autocomplete="off">
            <label for="wifiSsidInput">SSID:</label>
            <input type="text" id="wifiSsidInput" name="ssid" class="name-input" placeholder="Loading..."
                autocomplete="off">
            <label for="wifiPasswordInput" style="margin-top:10px;">Password:</label>
            <div style="display:flex;align-items:center;gap:8px;">
                <input type="password" id="wifiPasswordInput" name="password" class="name-input"
                    placeholder="Loading..." style="flex:1;" autocomplete="off">
                <button type="button" class="btn-set" style="padding:6px 12px;"
                    onclick="toggleWifiPassword()">Show</button>
            </div>
            <div style="margin-top:12px;">
                <label style="font-weight:bold;">Static IP Settings:</label>
                <div style="display:flex;align-items:center;gap:10px;margin-top:6px;">
                    <label class="switch">
                        <input type="checkbox" id="useStaticIpInput" name="useStaticIp">
                        <span class="slider"></span>
                    </label>
                    <span style="font-size:1em;">Use custom static IP</span>
                </div>
                <div style="display:flex;gap:8px;margin-top:6px;">
                    <input type="text" id="ipInput" name="ip" class="name-input" style="flex:1;"
                        placeholder="IP Address (e.g. 192.168.29.124)">
                    <input type="text" id="gatewayInput" name="gateway" class="name-input" style="flex:1;"
                        placeholder="Gateway (e.g. 192.168.29.1)" value="192.168.29.1">
                </div>
                <div style="display:flex;gap:8px;margin-top:6px;">
                    <input type="text" id="subnetInput" name="subnet" class="name-input" style="flex:1;"
                        placeholder="Subnet (e.g. 255.255.255.0)" value="255.255.255.0">
                    <input type="text" id="dns1Input" name="dns1" class="name-input" style="flex:1;"
                        placeholder="Primary DNS (e.g. 1.1.1.1)" value="1.1.1.1">
                    <input type="text" id="dns2Input" name="dns2" class="name-input" style="flex:1;"
                        placeholder="Secondary DNS (e.g. 1.0.0.1)" value="1.0.0.1">
                </div>
                <div style="display:flex;align-items:center;gap:10px;margin-top:10px;">
                    <button type="button" class="btn-set" onclick="setCurrentAsStaticIp()">Make this static IP</button>
                    <span style="display:inline-flex;align-items:center;gap:4px;position:relative;cursor:pointer;"
                        onmouseenter="this.querySelector('.tooltip').style.display='block'"
                        onmouseleave="this.querySelector('.tooltip').style.display='none'">
                        <svg xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16"
                            style="fill:#ff5252;vertical-align:middle;">
                            <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" />
                        </svg>
                        <span class="tooltip">Reboot required</span>
                    </span>
                </div>
            </div>
            <div style="display:flex;align-items:center;gap:10px;margin-top:10px;">
                <button class="btn-set" type="submit">Save WiFi</button>
                <span style="display:inline-flex;align-items:center;gap:4px;position:relative;cursor:pointer;"
                    onmouseenter="this.querySelector('.tooltip').style.display='block'"
                    onmouseleave="this.querySelector('.tooltip').style.display='none'">
                    <svg xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16"
                        style="fill:#ff5252;vertical-align:middle;">
                        <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" />
                    </svg>
                    <span class="tooltip">Reboot required</span>
                </span>
            </div>
        </form>
        <div id="wifiSaveStatus" style="margin-top:8px;font-size:0.9em;"></div>
        <div id="wifiRebootMsg" style="margin-top:8px;font-size:1em;color:#4CAF50;display:none;"></div>
        <div id="wifiNewIpInfo" style="margin-top:8px;font-size:0.95em;color:#4CAF50;display:none;"></div>
    </div>

    <div class="grid-container">
        <div class="settings-container">
            <h3 class="settings-title">RELAY 1 Name</h3>
            <input type="text" id="nameInput_1" class="name-input" placeholder="Loading current name...">
            <button class="btn-set" onclick="setLEDName(1)">Set Name</button>
        </div>
        <div class="settings-container">
            <h3 class="settings-title">RELAY 2 Name</h3>
            <input type="text" id="nameInput_2" class="name-input" placeholder="Loading current name...">
            <button class="btn-set" onclick="setLEDName(2)">Set Name</button>
        </div>
    </div>

    <!-- NTP/Timezone Settings -->
    <div class="settings-container" style="max-width:600px; margin-top:20px;">
        <h3 class="settings-title">NTP & Timezone Settings</h3>
        <label for="ntpServerInput">NTP Server:</label>
        <input type="text" id="ntpServerInput" class="name-input" placeholder="e.g. in.pool.ntp.org">
        <label for="timezoneInput" style="margin-top:10px;">Timezone (e.g. +5:30, -4:00):</label>
        <input type="text" id="timezoneInput" class="name-input" placeholder="+5:30">
        <div style="display:flex;align-items:center;gap:10px;margin-top:10px;">
            <button class="btn-set" onclick="saveNtpSettings()">Save NTP/Timezone</button>
            <span style="display:inline-flex;align-items:center;gap:4px;position:relative;cursor:pointer;"
                onmouseenter="this.querySelector('.tooltip').style.display='block'"
                onmouseleave="this.querySelector('.tooltip').style.display='none'">
                <svg xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16"
                    style="fill:#ff5252;vertical-align:middle;">
                    <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" />
                </svg>
                <span class="tooltip">Reboot required</span>
            </span>
        </div>
        <div id="ntpSaveStatus" style="margin-top:8px;font-size:0.9em;"></div>
    </div>

    <div style="width:100%;max-width:600px;display:flex;justify-content:center;margin:18px auto 0 auto;">
        <button class="btn-set"
            style="background:#1976D2;color:#fff;font-size:0.95em;padding:6px 18px;width:auto;min-width:120px;"
            onclick="window.location.href='specs.html'">Hardware Specs</button>
    </div>

    <footer class="version-footer">
        <span id="versionInfo">Checking version...</span>
        <span class="copyright">&copy; 2025 desiFish. All rights reserved.</span>
    </footer>

    <div id="restoreOverlay" style="display:none">
        <div class="restore-spinner"></div>
        <div class="restore-message">Restoring configuration... Please wait.</div>
    </div>

    <script>
        // Connection status check
        function checkConnection() {
            fetch('/api/status')
                .then(response => response.text())
                .then(status => {
                    const conn = document.getElementById('connectionStatus');
                    if (status === 'true') {
                        conn.className = 'connection-status online';
                        conn.querySelector('span:last-child').textContent = 'Online';
                    } else {
                        conn.className = 'connection-status offline';
                        conn.querySelector('span:last-child').textContent = 'Offline';
                    }
                })
                .catch(() => {
                    const conn = document.getElementById('connectionStatus');
                    conn.className = 'connection-status offline';
                    conn.querySelector('span:last-child').textContent = 'Offline';
                });
        }

        function fetchVersion() {
            fetch('/api/version')
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.text();
                })
                .then(version => {
                    document.getElementById('versionInfo').textContent = version;
                })
                .catch(error => {
                    console.error('Error fetching version:', error);
                    document.getElementById('versionInfo').textContent = 'error';
                });
        }

        function fetchLEDNames() {
            [1, 2].forEach(ledId => {
                fetch(`/api/led${ledId}/name`)
                    .then(response => {
                        if (!response.ok) throw new Error('Network response was not ok');
                        return response.text();
                    })
                    .then(name => {
                        const input = document.getElementById(`nameInput_${ledId}`);
                        input.placeholder = `Current name: ${name}`;
                    })
                    .catch(error => {
                        console.error('Error fetching LED name:', error);
                        const input = document.getElementById(`nameInput_${ledId}`);
                        input.placeholder = 'Error loading name';
                    });
            });
        }

        function setLEDName(ledId) {
            const input = document.getElementById(`nameInput_${ledId}`);
            const newName = input.value.trim();

            if (!newName) {
                alert('Please enter a name');
                return;
            }

            fetch(`/api/led${ledId}/name`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            })
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    input.value = '';
                    input.placeholder = `Current name: ${newName}`;
                    alert('Name updated successfully');
                })
                .catch(error => {
                    console.error('Error setting LED name:', error);
                    alert('Failed to update name');
                });
        }

        // Update time function
        function updateTime() {
            fetch('/api/time/update', {
                method: 'POST'
            })
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    alert('Time updated requested successfully');
                })
                .catch(error => {
                    console.error('Error updating time:', error);
                    alert('Failed to update time');
                });
        }

        // Download configuration as JSON file (client-side only)
        async function downloadConfig() {
            const overlay = document.getElementById('restoreOverlay');
            // Set backup-specific message
            overlay.querySelector('.restore-message').textContent = 'Backing up configuration... Please wait.';
            overlay.style.display = 'flex';
            try {
                // Fetch relay configs
                const relayIds = [1, 2];
                const relayPromises = relayIds.map(async (id) => {
                    const [name, mode, schedule, timer, toggle, sys] = await Promise.all([
                        fetch(`/api/led${id}/name`).then(r => r.text()).catch(() => null),
                        fetch(`/api/led${id}/mode`).then(r => r.text()).catch(() => null),
                        fetch(`/api/led${id}/schedule`).then(r => r.json()).catch(() => ({})),
                        fetch(`/api/led${id}/timer/state`).then(r => r.json()).catch(() => ({})),
                        fetch(`/api/led${id}/toggle-mode/state`).then(r => r.json()).catch(() => ({})),
                        fetch(`/api/led${id}/system/state`).then(r => r.json()).catch(() => ({})),
                    ]);
                    // Convert onTime/offTime in schedule from integer to HH:MM string if present
                    let newSchedule = schedule;
                    if (mode === "auto" && schedule && typeof schedule.onTime === 'number' && typeof schedule.offTime === 'number') {
                        const toHHMM = (val) => {
                            const h = Math.floor(val / 100).toString().padStart(2, '0');
                            const m = (val % 100).toString().padStart(2, '0');
                            return `${h}:${m}`;
                        };
                        newSchedule = {
                            ...schedule,
                            onTime: toHHMM(schedule.onTime),
                            offTime: toHHMM(schedule.offTime)
                        };
                    }
                    // Only include the configuration relevant to the active mode
                    let modeConfig = {};
                    if (mode === "auto") {
                        modeConfig = { mode, schedule: newSchedule };
                    } else if (mode === "timer") {
                        modeConfig = { mode, timer };
                    } else if (mode === "toggle") {
                        modeConfig = { mode, toggle };
                    } else {
                        modeConfig = { mode };
                    }
                    return {
                        id,
                        name,
                        ...modeConfig,
                        system: sys
                    };
                });

                // Attempt to fetch WiFi info (if available)
                let wifi = {};
                try {
                    wifi = await fetch('/api/wifi').then(r => r.json());
                } catch (e) {
                    wifi = {
                        ssid: "Not available (client-side only)",
                        password: "Not available (client-side only)"
                    };
                }

                // Add static IP details from form if useStaticIp is checked
                const useStaticIp = document.getElementById('useStaticIpInput').checked;
                if (useStaticIp) {
                    wifi.useStaticIp = true;
                    wifi.ip = document.getElementById('ipInput').value;
                    wifi.gateway = document.getElementById('gatewayInput').value;
                    wifi.subnet = document.getElementById('subnetInput').value;
                    wifi.dns1 = document.getElementById('dns1Input').value;
                    wifi.dns2 = document.getElementById('dns2Input').value;
                }

                // Fetch NTP config
                let ntp = {};
                try {
                    ntp = await fetch('/api/ntp').then(r => r.json());
                } catch (e) {
                    ntp = {
                        ntpServer: "in.pool.ntp.org",
                        timezoneOffset: 19800,
                        timezoneString: "+5:30"
                    };
                }

                const relays = await Promise.all(relayPromises);
                const config = {
                    generatedAt: new Date().toISOString(),
                    wifi,
                    ntp,
                    relays
                };
                const blob = new Blob([JSON.stringify(config, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const now = new Date();
                const y = now.getFullYear();
                const m = String(now.getMonth() + 1).padStart(2, '0');
                const d = String(now.getDate()).padStart(2, '0');
                const dateStr = `${d}${m}${y}`;
                a.download = `aquariumBackup${dateStr}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                alert("Failed to download config: " + err);
            } finally {
                overlay.style.display = 'none';
            }
        }

        // Helper: Convert timezone string (+5:30, -4:00) to seconds offset
        function timezoneToSeconds(tz) {
            // Accepts "+5:30", "-4:00", "+09", "-11", etc.
            const match = tz.match(/^([+-])(\d{1,2})(?::(\d{2}))?$/);
            if (!match) return null;
            const sign = match[1] === '+' ? 1 : -1;
            const hours = parseInt(match[2], 10);
            const mins = match[3] ? parseInt(match[3], 10) : 0;
            return sign * (hours * 3600 + mins * 60);
        }

        // Save NTP/Timezone settings to server
        async function saveNtpSettings() {
            const ntpServer = document.getElementById('ntpServerInput').value.trim();
            const timezone = document.getElementById('timezoneInput').value.trim();
            const statusDiv = document.getElementById('ntpSaveStatus');
            statusDiv.textContent = "";

            if (!ntpServer) {
                statusDiv.textContent = "Please enter NTP server address.";
                statusDiv.style.color = "#ff5252";
                return;
            }
            if (!timezone) {
                statusDiv.textContent = "Please enter timezone (e.g. +5:30, -4:00).";
                statusDiv.style.color = "#ff5252";
                return;
            }
            const offset = timezoneToSeconds(timezone);
            if (offset === null || isNaN(offset)) {
                statusDiv.textContent = "Invalid timezone format.";
                statusDiv.style.color = "#ff5252";
                return;
            }

            try {
                const resp = await fetch('/api/ntp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ntpServer,
                        timezone,
                        offset
                    })
                });
                let backendMsg = "";
                if (resp.ok) {
                    // Try to parse backend message if present
                    try {
                        const result = await resp.json();
                        backendMsg = result && result.message ? result.message : "NTP/Timezone updated successfully.";
                    } catch {
                        backendMsg = "NTP/Timezone updated successfully.";
                    }
                    statusDiv.textContent = backendMsg;
                    statusDiv.style.color = "#4CAF50";
                    // Alert user and trigger reboot after confirmation
                    setTimeout(async () => {
                        alert(backendMsg + "\n\nThe device will now reboot to apply changes. Please wait a few seconds before reconnecting. ");
                        statusDiv.textContent += " Rebooting...";
                        statusDiv.style.color = "#1976D2";
                        await fetch('/api/reboot', { method: 'POST' });
                        setTimeout(() => {
                            location.reload();
                        }, 2000);
                    }, 1200);
                } else {
                    try {
                        const result = await resp.json();
                        backendMsg = result && result.error ? result.error : "Failed to update NTP/Timezone.";
                    } catch {
                        backendMsg = "Failed to update NTP/Timezone.";
                    }
                    statusDiv.textContent = backendMsg;
                    statusDiv.style.color = "#ff5252";
                }
            } catch (e) {
                statusDiv.textContent = "Error communicating with server.";
                statusDiv.style.color = "#ff5252";
                console.error("NTP update error:", e);
            }
        }

        // WiFi settings logic
        let currentWifiSsid = "";
        let currentWifiPassword = "";

        // Fetch current WiFi info and static IP settings and set as value/placeholder
        function fetchCurrentWifiInfo() {
            fetch('/api/wifi', { headers: { 'Accept': 'application/json' } })
                .then(r => {
                    const ct = r.headers.get("content-type") || "";
                    if (!ct.includes("application/json")) throw new Error("Not JSON");
                    return r.json();
                })
                .then(data => {
                    currentWifiSsid = data.ssid || "";
                    currentWifiPassword = data.password || "";
                    const ssidInput = document.getElementById('wifiSsidInput');
                    const pwInput = document.getElementById('wifiPasswordInput');
                    // Set value if present, else clear value and set placeholder
                    if (currentWifiSsid) {
                        ssidInput.value = currentWifiSsid;
                        ssidInput.placeholder = "";
                    } else {
                        ssidInput.value = "";
                        ssidInput.placeholder = "Enter WiFi SSID";
                    }
                    if (currentWifiPassword) {
                        pwInput.value = currentWifiPassword;
                        pwInput.placeholder = "";
                    } else {
                        pwInput.value = "";
                        pwInput.placeholder = "Enter password";
                    }
                    // Always load current IP/gateway/subnet/dns values from backend (router-assigned if connected)
                    document.getElementById('ipInput').value = data.ip || "";
                    document.getElementById('gatewayInput').value = data.gateway || "";
                    document.getElementById('subnetInput').value = data.subnet || "";
                    document.getElementById('dns1Input').value = data.dns1 || "";
                    document.getElementById('dns2Input').value = data.dns2 || "";
                    document.getElementById('useStaticIpInput').checked = !!data.useStaticIp;
                    updateMakeStaticBtnState();
                })
                .catch((err) => {
                    document.getElementById('wifiSsidInput').value = "";
                    document.getElementById('wifiSsidInput').placeholder = "Enter WiFi SSID";
                    document.getElementById('wifiPasswordInput').value = "";
                    document.getElementById('wifiPasswordInput').placeholder = "Enter password";
                    document.getElementById('ipInput').value = "";
                    document.getElementById('gatewayInput').value = "";
                    document.getElementById('subnetInput').value = "";
                    document.getElementById('dns1Input').value = "";
                    document.getElementById('dns2Input').value = "";
                    document.getElementById('useStaticIpInput').checked = false;
                    updateMakeStaticBtnState();
                });
        }

        // Clock update logic
        function updateClockDisplay() {
            fetch('/api/clock?_=' + Date.now())
                .then(r => r.json())
                .then(data => {
                    const clockElem = document.getElementById('clockDisplay');
                    if (data && data.error === "RTC_FAILED") {
                        clockElem.textContent = "RTC ERROR";
                        console.error("RTC error: RTC_FAILED");
                    } else if (data && data.time && data.date && data.dow) {
                        // data.date is expected in format yyyy-mm-dd or similar
                        let formattedDate = data.date;
                        if (/^(\d{4})-(\d{2})-(\d{2})$/.test(data.date)) {
                            const [year, month, day] = data.date.split('-');
                            formattedDate = `${day}-${month}-${year}`;
                        }
                        clockElem.textContent = `${data.time}, ${data.dow} ${formattedDate}`;
                    } else {
                        clockElem.textContent = "--:-- --, ---- --/--/----";
                        console.error("RTC error: Invalid data", data);
                    }
                })
                .catch((err) => {
                    document.getElementById('clockDisplay').textContent = "RTC ERROR";
                    console.error("RTC fetch error:", err);
                });
        }

        // Initialize
        fetchVersion();
        setInterval(checkConnection, 5000);
        checkConnection();
        fetchLEDNames();
        updateClockDisplay();
        setInterval(updateClockDisplay, 30000); // every 30 seconds

        // Set current dynamic IP/gateway/subnet/dns as static IP fields and save as static
        function setCurrentAsStaticIp() {
            // Set the "Use static IP" checkbox to true
            document.getElementById('useStaticIpInput').checked = true;
            // Submit the WiFi form (will use the current values in the fields)
            document.getElementById('wifiForm').requestSubmit();
            // Wait 2 seconds, then call /api/reboot to trigger device reboot
            setTimeout(async () => {
                await fetch('/api/reboot', { method: 'POST' });
                // Optionally reload the page after another 2 seconds
                setTimeout(() => {
                    location.reload();
                }, 2000);
            }, 2000);
        }

        // On page load, fetch and set current NTP/Timezone values
        function fetchCurrentNtpSettings() {
            fetch('/api/ntp', { headers: { 'Accept': 'application/json' } })
                .then(r => {
                    const ct = r.headers.get("content-type") || "";
                    if (!ct.includes("application/json")) throw new Error("Not JSON");
                    return r.json();
                })
                .then(data => {
                    document.getElementById('ntpServerInput').value = data.ntpServer || '';
                    document.getElementById('timezoneInput').value = data.timezoneString || '';
                })
                .catch(() => {
                    // fallback: leave fields as-is
                });
        }
        fetchCurrentNtpSettings();

        // Fetch current WiFi info and static IP settings and set as value/placeholder
        function fetchCurrentWifiInfo() {
            fetch('/api/wifi', { headers: { 'Accept': 'application/json' } })
                .then(r => {
                    const ct = r.headers.get("content-type") || "";
                    if (!ct.includes("application/json")) throw new Error("Not JSON");
                    return r.json();
                })
                .then(data => {
                    currentWifiSsid = data.ssid || "";
                    currentWifiPassword = data.password || "";
                    const ssidInput = document.getElementById('wifiSsidInput');
                    const pwInput = document.getElementById('wifiPasswordInput');
                    // Set value if present, else clear value and set placeholder
                    if (currentWifiSsid) {
                        ssidInput.value = currentWifiSsid;
                        ssidInput.placeholder = "";
                    } else {
                        ssidInput.value = "";
                        ssidInput.placeholder = "Enter WiFi SSID";
                    }
                    if (currentWifiPassword) {
                        pwInput.value = currentWifiPassword;
                        pwInput.placeholder = "";
                    } else {
                        pwInput.value = "";
                        pwInput.placeholder = "Enter password";
                    }
                    // Always load current IP/gateway/subnet/dns values from backend (router-assigned if connected)
                    document.getElementById('ipInput').value = data.ip || "";
                    document.getElementById('gatewayInput').value = data.gateway || "";
                    document.getElementById('subnetInput').value = data.subnet || "";
                    document.getElementById('dns1Input').value = data.dns1 || "";
                    document.getElementById('dns2Input').value = data.dns2 || "";
                    document.getElementById('useStaticIpInput').checked = !!data.useStaticIp;
                    updateMakeStaticBtnState();
                })
                .catch((err) => {
                    document.getElementById('wifiSsidInput').value = "";
                    document.getElementById('wifiSsidInput').placeholder = "Enter WiFi SSID";
                    document.getElementById('wifiPasswordInput').value = "";
                    document.getElementById('wifiPasswordInput').placeholder = "Enter password";
                    document.getElementById('ipInput').value = "";
                    document.getElementById('gatewayInput').value = "";
                    document.getElementById('subnetInput').value = "";
                    document.getElementById('dns1Input').value = "";
                    document.getElementById('dns2Input').value = "";
                    document.getElementById('useStaticIpInput').checked = false;
                    updateMakeStaticBtnState();
                });
        }

        document.getElementById('wifiForm').addEventListener('submit', async function (e) {
            e.preventDefault();
            const statusDiv = document.getElementById('wifiSaveStatus');
            const rebootDiv = document.getElementById('wifiRebootMsg');
            statusDiv.textContent = "";
            rebootDiv.style.display = "none";
            rebootDiv.textContent = "";

            const ssid = document.getElementById('wifiSsidInput').value.trim();
            const password = document.getElementById('wifiPasswordInput').value.trim();
            const ip = document.getElementById('ipInput').value.trim();
            const gateway = document.getElementById('gatewayInput').value.trim();
            const subnet = document.getElementById('subnetInput').value.trim();
            const dns1 = document.getElementById('dns1Input').value.trim();
            const dns2 = document.getElementById('dns2Input').value.trim();
            const useStaticIp = document.getElementById('useStaticIpInput').checked;

            if (!ssid) {
                statusDiv.textContent = "Please enter SSID.";
                statusDiv.style.color = "#ff5252";
                return;
            }
            if (!password) {
                statusDiv.textContent = "Please enter password.";
                statusDiv.style.color = "#ff5252";
                return;
            }

            // Build form data
            const formData = new FormData();
            formData.append("ssid", ssid);
            formData.append("password", password);
            if (ip) formData.append("ip", ip);
            if (gateway) formData.append("gateway", gateway);
            if (subnet) formData.append("subnet", subnet);
            if (dns1) formData.append("dns1", dns1);
            if (dns2) formData.append("dns2", dns2);
            formData.append("useStaticIp", useStaticIp ? "true" : "false");

            try {
                const resp = await fetch('/api/wifi', {
                    method: 'POST',
                    body: formData
                });
                const result = await resp.json();
                if (result.success) {
                    statusDiv.textContent = "";
                    rebootDiv.style.display = "block";
                    let ipMsg = "";
                    if (result.ip) {
                        ipMsg = `<br><b>Device IP after reboot:</b> <span style="color:#fff;background:#333;padding:2px 8px;border-radius:4px;">${result.ip}</span>`;
                    }
                    rebootDiv.innerHTML = "<b>WiFi settings saved!</b><br>The device will reboot in a few seconds.<br>Please reconnect to the new WiFi network if needed.<br>If the device IP changes, use the new IP to access the web interface." + ipMsg;
                    // Wait 2 seconds, then call /api/reboot to trigger reboot
                    setTimeout(async () => {
                        rebootDiv.innerHTML += "<br><span style='color:#aaa;font-size:0.95em;'>Rebooting now...</span>";
                        await fetch('/api/reboot', { method: 'POST' });
                    }, 2000);
                } else {
                    statusDiv.textContent = result.error || "Failed to update WiFi.";
                    statusDiv.style.color = "#ff5252";
                }
            } catch (e) {
                statusDiv.textContent = "Error communicating with server.";
                statusDiv.style.color = "#ff5252";
            }
        });

        // On page load, call fetchCurrentWifiInfo ONCE 
        fetchCurrentWifiInfo();

        // Ensure the Make Static IP button is enabled/disabled correctly on page load and on input
        const ipInput = document.getElementById('ipInput');
        const makeStaticBtn = document.querySelector('button[onclick="setCurrentAsStaticIp()"]');
        function updateMakeStaticBtnState() {
            makeStaticBtn.disabled = false; // Always enabled, simple button
        }
        ipInput.addEventListener('input', updateMakeStaticBtnState);
        updateMakeStaticBtnState();

        // Enable/disable static IP fields based on the checkbox
        const useStaticIpInput = document.getElementById('useStaticIpInput');
        const staticIpFields = [
            document.getElementById('ipInput'),
            document.getElementById('gatewayInput'),
            document.getElementById('subnetInput'),
            document.getElementById('dns1Input'),
            document.getElementById('dns2Input')
        ];
        function updateStaticIpFieldsState() {
            const enabled = useStaticIpInput.checked;
            staticIpFields.forEach(f => f.disabled = !enabled);
        }
        useStaticIpInput.addEventListener('change', updateStaticIpFieldsState);
        // Call once on page load
        updateStaticIpFieldsState();

        // Show/hide WiFi password
        function toggleWifiPassword() {
            const pwInput = document.getElementById('wifiPasswordInput');
            if (pwInput.type === 'password') {
                pwInput.type = 'text';
            } else {
                pwInput.type = 'password';
            }
        }

        // Restore configuration from JSON file
        async function restoreConfig(event) {
            const overlay = document.getElementById('restoreOverlay');
            // Set restore-specific message
            overlay.querySelector('.restore-message').textContent = 'Restoring configuration... Please wait.';
            overlay.style.display = 'flex';
            try {
                const file = event.target.files[0];
                if (!file) return;
                const text = await file.text();
                const config = JSON.parse(text);
                // Restore NTP
                if (config.ntp) {
                    await fetch('/api/ntp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            ntpServer: config.ntp.ntpServer,
                            timezone: config.ntp.timezoneString,
                            offset: config.ntp.timezoneOffset
                        })
                    });
                }
                // Restore relays
                if (Array.isArray(config.relays)) {
                    for (const relay of config.relays) {
                        // 1. Restore system state (enabled/disabled) first
                        if (relay.system) {
                            await fetch(`/api/led${relay.id}/system/state`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(relay.system)
                            });
                            // Wait a bit to ensure system state is set before mode
                            await new Promise(res => setTimeout(res, 150));
                        }
                        if (relay.name) {
                            await fetch(`/api/led${relay.id}/name`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ name: relay.name })
                            });
                        }
                        if (relay.mode) {
                            await fetch(`/api/led${relay.id}/mode`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ mode: relay.mode })
                            });
                            await new Promise(res => setTimeout(res, 200));
                        }
                        if (relay.mode === 'auto' && relay.schedule) {
                            console.log('Restoring schedule for relay', relay.id, relay.schedule);
                            const resp = await fetch(`/api/led${relay.id}/schedule`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(relay.schedule)
                            });
                            const result = await resp.text();
                            console.log('Schedule restore response for relay', relay.id, result);
                        }
                        if (relay.mode === 'timer' && relay.timer) {
                            // Start the timer with the saved duration if duration > 0
                            const duration = relay.timer.duration || 0;
                            if (duration > 0) {
                                await fetch(`/api/led${relay.id}/timer`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ duration: duration, start: true })
                                });
                            } else {
                                // If duration is 0, just stop the timer
                                await fetch(`/api/led${relay.id}/timer`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ duration: 0, start: false })
                                });
                            }
                        }
                        if (relay.mode === 'toggle' && relay.toggle) {
                            // Only send the relevant fields to /toggle-mode
                            await fetch(`/api/led${relay.id}/toggle-mode`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    onMinutes: relay.toggle.onMinutes,
                                    offMinutes: relay.toggle.offMinutes,
                                    start: !!relay.toggle.active
                                })
                            });
                        }
                        // Set relay ON/OFF if mode is manual and system.state is present
                        if (relay.mode === 'manual' && relay.system && relay.system.state) {
                            await fetch(`/api/led${relay.id}/toggle`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ state: relay.system.state })
                            });
                        }
                    }
                }
                // Restore WiFi
                if (config.wifi) {
                    const wifiForm = new FormData();
                    wifiForm.append('ssid', config.wifi.ssid || '');
                    wifiForm.append('password', config.wifi.password || '');
                    wifiForm.append('useStaticIp', config.wifi.useStaticIp ? 'true' : 'false');
                    if (config.wifi.useStaticIp) {
                        wifiForm.append('ip', config.wifi.ip || '');
                        wifiForm.append('gateway', config.wifi.gateway || '');
                        wifiForm.append('subnet', config.wifi.subnet || '');
                        wifiForm.append('dns1', config.wifi.dns1 || '');
                        wifiForm.append('dns2', config.wifi.dns2 || '');
                    }
                    await fetch('/api/wifi', { method: 'POST', body: wifiForm });
                }
                alert('Restore complete! Please go to the new IP address. Device will reboot now.');
                // Reboot the device after restore completes
                await fetch('/api/reboot', { method: 'POST' });
            } catch (e) {
                alert('Failed to restore config: ' + e);
            } finally {
                overlay.style.display = 'none';
            }
        }

        // Error polling: check /api/error every 5 seconds and alert if a new error message is present
        (function errorPoller() {
            let lastErrorMsg = "";
            async function pollError() {
                try {
                    const resp = await fetch('/api/error?_=' + Date.now());
                    if (!resp.ok) return;
                    const data = await resp.json();
                    const msg = (data && data.error) ? String(data.error).trim() : "";
                    if (msg && msg !== lastErrorMsg) {
                        alert("Device Error:\n\n" + msg);
                        lastErrorMsg = msg;
                    } else if (!msg) {
                        lastErrorMsg = "";
                    }
                } catch (e) {
                    // Ignore fetch errors
                } finally {
                    setTimeout(pollError, 5000);
                }
            }
            pollError();
        })();
    </script>
</body>

</html>